
/*
 * EMQX API
 *
 * No description provided (generated by Swagger Codegen https://github.com/swagger-api/swagger-codegen)
 *
 * API version: 5.1.3
 * Generated by: Swagger Codegen (https://github.com/swagger-api/swagger-codegen.git)
 */
package swagger

import (
	"context"
	"io/ioutil"
	"net/http"
	"net/url"
	"strings"
	"github.com/antihax/optional"
)

// Linger please
var (
	_ context.Context
)

type StatusApiService service
/*
StatusApiService
Serves as a health check for the node.&lt;br/&gt;Returns response to describe the status of the node and the application.&lt;br/&gt;&lt;br/&gt;This endpoint requires no authentication.&lt;br/&gt;&lt;br/&gt;Returns status code 200 if the EMQX application is up and running, 503 otherwise.&lt;br/&gt;This API was introduced in v5.0.10.&lt;br/&gt;The GET &#x60;/status&#x60; endpoint (without the &#x60;/api/...&#x60; prefix) is also an alias to this endpoint and works in the same way.&lt;br/&gt;This alias has been available since v5.0.0.&lt;br/&gt;&lt;br/&gt;Starting from v5.0.25 or e5.0.4, you can also use &#x27;format&#x27; parameter to get JSON format information.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param optional nil or *StatusApiStatusGetOpts - Optional Parameters:
     * @param "Format" (optional.String) -  Specify the response format, &#x27;text&#x27; (default) to return the HTTP body in free text,&lt;br/&gt;or &#x27;json&#x27; to return the HTTP body with a JSON object.

*/

type StatusApiStatusGetOpts struct {
    Format optional.String
}

func (a *StatusApiService) StatusGet(ctx context.Context, localVarOptionals *StatusApiStatusGetOpts) (*http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/status"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarHttpResponse, err
	}


	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		return localVarHttpResponse, newErr
	}

	return localVarHttpResponse, nil
}
